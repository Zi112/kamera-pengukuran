<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Pengukuran panjang</title>
  <style>
    :root{--bg:#0b1220;--panel:#0f1720;--accent:#1dd1a1;--muted:#9aa4b2}
    html,body{height:100%;margin:0;font-family:Segoe UI, Roboto, Arial;background:var(--bg);color:#eef}
    .app{height:100vh;display:flex;flex-direction:column}
    .view{position:relative;flex:1;display:flex;align-items:center;justify-content:center;overflow:hidden}
    video#cam{width:100%;height:100%;object-fit:cover}
    canvas#overlay{position:absolute;left:0;top:0;width:100%;height:100%}

    .topbar{position:absolute;left:12px;right:12px;top:12px;display:flex;justify-content:space-between;align-items:center;z-index:20}
    .brand{background:rgba(2,6,23,0.6);padding:8px 12px;border-radius:10px;font-weight:700}
    .controls{background:rgba(2,6,23,0.6);padding:8px;border-radius:10px;display:flex;gap:8px;align-items:center}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#eef;padding:8px 10px;border-radius:8px;cursor:pointer}
    .btn.active{border-color:var(--accent);box-shadow:0 0 8px rgba(29,209,161,0.12)}

    .panel{position:absolute;left:12px;bottom:12px;right:12px;z-index:20;background:linear-gradient(180deg, rgba(2,6,23,0.2), rgba(2,6,23,0.6));backdrop-filter:blur(6px);padding:12px;border-radius:12px;display:flex;align-items:center;gap:12px}
    .panel .left{display:flex;flex-direction:column;gap:6px}
    .panel .right{margin-left:auto;display:flex;flex-direction:column;align-items:flex-end}
    select,input{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#eef;padding:8px;border-radius:8px}
    .result{font-weight:700;color:var(--accent);font-size:18px}
    .hint{font-size:13px;color:var(--muted)}

    /* ruler styling (drawn on canvas) */
    @media (max-width:700px){ .brand{font-size:14px} .result{font-size:16px} }
  </style>
</head>
<body>
  <div class="app">
    <div class="view">
      <video id="cam" autoplay playsinline></video>
      <canvas id="overlay"></canvas>

      <div class="topbar">
        <div class="brand">Pngukuran Panjang menggunakan Kamera AR</div>
        <div class="controls">
          <button id="calBtn" class="btn">Kalibrasi</button>
          <button id="measureBtn" class="btn">Ukur</button>
          <button id="autoDetectBtn" class="btn">Auto</button>
          <button id="screenshotBtn" class="btn">Screenshot</button>
          <button id="clearBtn" class="btn">Reset</button>
          <label class="hint" style="margin-left:8px">Satuan:
            <select id="unitSel">
              <option value="cm">cm</option>
              <option value="m">m</option>
              <option value="in">in</option>
            </select>
          </label>
        </div>
      </div>

      <div class="panel">
        <div class="left">
          <div class="hint">Kalibrasi: letakkan penggaris atau objek referensi, klik dua titik ujung, masukkan panjang nyata lalu tekan <strong>Terapkan</strong>.</div>
          <div style="display:flex;gap:8px;align-items:center">
            <input id="refLen" type="number" step="0.01" placeholder="Panjang referensi" style="width:120px" value="30">
            <select id="refUnit"><option value="cm">cm</option><option value="m">m</option><option value="in">in</option></select>
            <button id="applyCal" class="btn">Terapkan</button>
            <button id="saveCalBtn" class="btn">Simpan Kalibrasi</button>
          </div>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <button id="saveMeasureBtn" class="btn" style="background:var(--accent);color:#042;">Simpan Pengukuran</button>
            <button id="showGuideBtn" class="btn">Panduan</button>
          </div>
        </div>

        <div class="right">
          <div class="result" id="resultText">Belum ada pengukuran</div>
          <div class="hint" id="scaleText">Skala: - px/unit</div>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <button id="exportCsv" class="btn">Ekspor CSV</button>
            <button id="clearHistory" class="btn">Hapus Riwayat</button>
          </div>
        </div>
      </div>

      <div id="historyPanel" style="position:absolute;right:12px;top:72px;z-index:30;max-width:320px;background:rgba(2,6,23,0.7);padding:10px;border-radius:10px;color:#eef;display:none">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px"><strong>Riwayat Pengukuran</strong><button id="closeHistory" class="btn">×</button></div>
        <div id="historyList" style="max-height:320px;overflow:auto"></div>
      </div>

      <div id="guideOverlay" style="position:absolute;inset:0;z-index:40;background:rgba(0,0,0,0.7);color:#fff;display:none;padding:18px;overflow:auto">
        <button id="closeGuide" class="btn" style="position:absolute;right:18px;top:18px">Tutup</button>
        <h2>Panduan Singkat</h2>
        <ol>
          <li>Tekan <strong>Kalibrasi</strong>, lalu tap dua titik di ujung objek referensi (mis. penggaris).</li>
          <li>Masukkan panjang nyata pada kotak <em>Panjang referensi</em> dan pilih satuan.
            Tekan <strong>Terapkan</strong> lalu <strong>Simpan Kalibrasi</strong> jika ingin menyimpan pengaturan.</li>
          <li>Tekan <strong>Ukur</strong>, tap/seret dua titik pada objek yang ingin diukur. Hasil akan ditampilkan di panel.</li>
          <li>Untuk menyimpan hasil pengukuran, tekan <strong>Simpan Pengukuran</strong>. Lihat riwayat di pojok kanan atas.</li>
        </ol>
        <p class="hint">Catatan: ini demo sederhana — akurasi terbaik jika kamera sejajar dengan objek dan pengkalibrasian dilakukan dekat area pengukuran.</p>
      </div>
    </div>
  </div>

  <script>
    // Elements
    const video = document.getElementById('cam');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const calBtn = document.getElementById('calBtn');
    const measureBtn = document.getElementById('measureBtn');
    const clearBtn = document.getElementById('clearBtn');
    const refLenInput = document.getElementById('refLen');
    const refUnit = document.getElementById('refUnit');
    const applyCal = document.getElementById('applyCal');
    const unitSel = document.getElementById('unitSel');
    const resultText = document.getElementById('resultText');
    const scaleText = document.getElementById('scaleText');

    let DPR = window.devicePixelRatio || 1;
    let mode = null; // 'cal' | 'measure' | null
    let handles = []; // draggable points [{x,y,drag}]
    let pxPerUnit = null; // pixels per selected unit (e.g., px/cm)
    let unit = 'cm';

    unitSel.addEventListener('change', ()=>{ unit = unitSel.value; updateResult(); });

    // Start camera
    async function startCamera(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
        video.srcObject = stream;
        await video.play();
        resize();
        requestAnimationFrame(loop);
      }catch(e){ alert('Gagal akses kamera: '+e.message); }
    }

    function resize(){
      const w = video.clientWidth; const h = video.clientHeight;
      canvas.width = Math.floor(w * DPR); canvas.height = Math.floor(h * DPR);
      canvas.style.width = w+'px'; canvas.style.height = h+'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    window.addEventListener('resize', resize);

    // Input handling (mouse + touch)
    let activeHandle = null;
    function getPos(e){
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return {x: clientX - rect.left, y: clientY - rect.top};
    }

    canvas.addEventListener('pointerdown', (ev)=>{
      const p = getPos(ev);
      // find nearest handle
      let minD = 30; let nearest = null;
      for(const h of handles){ const d = Math.hypot(h.x-p.x, h.y-p.y); if(d<minD){ minD=d; nearest=h; }}
      if(nearest){ nearest.drag = true; activeHandle = nearest; }
      else{
        if(mode==='cal' || mode==='measure'){
          if(handles.length<2){ handles.push({x:p.x,y:p.y,drag:true}); activeHandle = handles[handles.length-1]; }
        }
      }
    });
    window.addEventListener('pointermove', (ev)=>{ if(!activeHandle) return; const p=getPos(ev); activeHandle.x=p.x; activeHandle.y=p.y; ev.preventDefault(); updateResult(); });
    window.addEventListener('pointerup', ()=>{ if(activeHandle) activeHandle.drag=false; activeHandle=null; });

    calBtn.addEventListener('click', ()=>{ setMode('cal'); });
    measureBtn.addEventListener('click', ()=>{ setMode('measure'); });
    clearBtn.addEventListener('click', ()=>{ handles=[]; pxPerUnit=null; scaleText.textContent='Skala: - px/unit'; resultText.textContent='Belum ada pengukuran'; });
    applyCal.addEventListener('click', ()=>{ applyCalibration(); });

    function setMode(m){ mode = m; calBtn.classList.toggle('active', m==='cal'); measureBtn.classList.toggle('active', m==='measure'); resultText.textContent = (m==='cal')? 'Mode Kalibrasi: tambahkan 2 titik.' : 'Mode Ukur: tambahkan 2 titik.'; }

    function applyCalibration(){
      if(handles.length<2){ alert('Pilih dua titik pada referensi untuk kalibrasi.'); return; }
      const refV = parseFloat(refLenInput.value);
      if(!isFinite(refV) || refV<=0){ alert('Masukkan nilai panjang referensi yang valid.'); return; }
      // convert ref unit to selected unit (we'll store px per chosen 'unit')
      const refUnitVal = refUnit.value; // 'cm'/'m'/'in'
      const refInSelected = convertUnits(refV, refUnitVal, unit); // value in selected unit
      const dpx = euclid(handles[0], handles[1]);
      pxPerUnit = dpx / refInSelected; // px per (selected unit)
      scaleText.textContent = 'Skala: '+pxPerUnit.toFixed(3)+' px/'+unit;
      resultText.textContent = 'Kalibrasi selesai';
    }

    // --- Persistence: save/load calibration and measurements ---
    const STORAGE_KEY_CAL = 'kaldif_calibration';
    const STORAGE_KEY_MEAS = 'kaldif_measurements';

    function saveCalibrationToStorage(){
      if(!pxPerUnit) return alert('Belum ada kalibrasi untuk disimpan.');
      const data = {pxPerUnit, unit};
      localStorage.setItem(STORAGE_KEY_CAL, JSON.stringify(data));
      alert('Kalibrasi disimpan.');
    }

    function loadCalibrationFromStorage(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY_CAL);
        if(!raw) return;
        const obj = JSON.parse(raw);
        pxPerUnit = obj.pxPerUnit; unit = obj.unit || unit;
        unitSel.value = unit;
        scaleText.textContent = 'Skala: '+pxPerUnit.toFixed(3)+' px/'+unit;
        resultText.textContent = 'Kalibrasi dimuat dari penyimpanan.';
      }catch(e){ console.warn('Load cal failed',e); }
    }

    function saveMeasurementRecord(rec){
      const raw = localStorage.getItem(STORAGE_KEY_MEAS); let arr = raw?JSON.parse(raw):[];
      arr.unshift(rec); // latest first
      localStorage.setItem(STORAGE_KEY_MEAS, JSON.stringify(arr));
      renderHistory();
    }

    function loadMeasurements(){
      const raw = localStorage.getItem(STORAGE_KEY_MEAS); return raw?JSON.parse(raw):[];
    }

    function clearMeasurements(){ localStorage.removeItem(STORAGE_KEY_MEAS); renderHistory(); }

    function exportMeasurementsCSV(){ const arr = loadMeasurements(); if(!arr.length){ alert('Tidak ada data untuk diekspor'); return; }
      const lines = ['timestamp,unit,value,px'];
      for(const r of arr){ lines.push([r.ts, r.unit, r.value, r.px].join(',')); }
      const csv = lines.join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'kaldif_measurements.csv'; a.click(); URL.revokeObjectURL(url);
    }

    function renderHistory(){ const container = document.getElementById('historyList'); container.innerHTML=''; const arr = loadMeasurements(); if(!arr.length){ container.innerHTML='<div class="hint">Belum ada pengukuran</div>'; return; }
      for(const r of arr){ const d = document.createElement('div'); d.style.padding='6px'; d.style.borderBottom='1px solid rgba(255,255,255,0.04)'; d.innerHTML = `<div style="display:flex;justify-content:space-between"><div><div>${new Date(r.ts).toLocaleString()}</div><div style="font-weight:700">${r.value} ${r.unit}</div></div><div style="text-align:right"><div>${r.px.toFixed(1)} px</div><button data-ts="${r.ts}" class="btn small">Hapus</button></div></div>`; container.appendChild(d);
      }
      // attach delete handlers
      container.querySelectorAll('button[data-ts]').forEach(b=>b.addEventListener('click', ()=>{ const ts=b.getAttribute('data-ts'); let arr=loadMeasurements(); arr = arr.filter(x=>String(x.ts)!==String(ts)); localStorage.setItem(STORAGE_KEY_MEAS, JSON.stringify(arr)); renderHistory(); }));
    }

    // wire storage buttons
    document.getElementById('saveCalBtn').addEventListener('click', saveCalibrationToStorage);
    document.getElementById('saveMeasureBtn').addEventListener('click', ()=>{
      if(handles.length<2) return alert('Buat pengukuran terlebih dahulu (2 titik).');
      const dpx = euclid(handles[0], handles[1]);
      if(!pxPerUnit) return alert('Kalibrasi diperlukan sebelum menyimpan pengukuran.');
      const val = +(dpx/pxPerUnit).toFixed(3);
      const rec = {ts: Date.now(), unit, value: val, px: +(dpx.toFixed(1))};
      saveMeasurementRecord(rec);
      alert('Pengukuran disimpan.');
    });
    document.getElementById('exportCsv').addEventListener('click', exportMeasurementsCSV);
    document.getElementById('clearHistory').addEventListener('click', ()=>{ if(confirm('Hapus semua riwayat?')){ clearMeasurements(); }});
    document.getElementById('showGuideBtn').addEventListener('click', ()=>{ document.getElementById('guideOverlay').style.display='block'; });
    document.getElementById('closeGuide').addEventListener('click', ()=>{ document.getElementById('guideOverlay').style.display='none'; });
    document.getElementById('closeHistory').addEventListener('click', ()=>{ document.getElementById('historyPanel').style.display='none'; });

    // show history on click of header brand (quick access)
    document.querySelector('.brand').addEventListener('click', ()=>{ const hp = document.getElementById('historyPanel'); hp.style.display = hp.style.display==='block'?'none':'block'; renderHistory(); });

    // load saved calibration and history on start
    loadCalibrationFromStorage(); renderHistory();

    // --- Auto-detect and Screenshot features ---
    document.getElementById('autoDetectBtn').addEventListener('click', autoDetectHandles);
    document.getElementById('screenshotBtn').addEventListener('click', takeScreenshot);

    // Auto-detect: simple vertical-edge detector near center
    async function autoDetectHandles(){
      // capture current video frame
      const temp = document.createElement('canvas');
      const w = video.videoWidth; const h = video.videoHeight;
      if(!w || !h){ alert('Frame belum siap, coba lagi.'); return; }
      temp.width = w; temp.height = h; const tctx = temp.getContext('2d');
      tctx.drawImage(video, 0, 0, w, h);
      const img = tctx.getImageData(0,0,w,h);
      // convert to grayscale and compute vertical gradient (simple Sobel-like)
      const gray = new Float32Array(w*h);
      for(let i=0;i<w*h;i++){ const r = img.data[i*4], g=img.data[i*4+1], b=img.data[i*4+2]; gray[i]=0.2989*r + 0.5870*g + 0.1140*b; }
      // vertical gradient kernel [-1,0,1] horizontally
      const grad = new Float32Array(w*h);
      for(let y=0;y<h;y++){
        for(let x=1;x<w-1;x++){
          const idx = y*w + x;
          grad[idx] = Math.abs(gray[idx+1] - gray[idx-1]);
        }
      }
      // focus search near center column +/- 15% width
      const cx = Math.floor(w/2), range = Math.floor(w*0.15);
      // sum gradient vertically per column
      let bestCol = cx; let bestVal = -1;
      for(let col=cx-range; col<=cx+range; col++){
        let sum = 0;
        for(let y=0;y<h;y++){ sum += grad[y*w + col]; }
        if(sum>bestVal){ bestVal=sum; bestCol=col; }
      }
      // find topmost and bottommost strong edges in that column
      // threshold as fraction of max grad in column
      let maxG=0; for(let y=0;y<h;y++){ maxG = Math.max(maxG, grad[y*w + bestCol]); }
      const thresh = Math.max(8, maxG*0.25);
      let top = null, bottom = null;
      for(let y=0;y<h;y++){ if(grad[y*w + bestCol] >= thresh){ top = y; break; } }
      for(let y=h-1;y>=0;y--){ if(grad[y*w + bestCol] >= thresh){ bottom = y; break; } }
      if(top===null || bottom===null || bottom-top < 6){ alert('Auto-detect gagal, coba posisi kamera lebih stabil atau gunakan kalibrasi manual.'); return; }
      // map to canvas coords (video may be scaled to fit canvas)
      const rect = canvas.getBoundingClientRect();
      const scaleX = rect.width / w; const scaleY = rect.height / h; const scale = (scaleX+scaleY)/2;
      const cxCanvas = (bestCol * rect.width / w);
      const topC = top * rect.height / h; const botC = bottom * rect.height / h;
      // set handles
      handles = [{x:cxCanvas, y:topC, drag:false}, {x:cxCanvas, y:botC, drag:false}];
      updateResult();
      document.getElementById('historyPanel').style.display='block';
    }

    // Screenshot: capture video + overlay and download image
    function takeScreenshot(){
      const out = document.createElement('canvas');
      const w = video.videoWidth || canvas.clientWidth; const h = video.videoHeight || canvas.clientHeight;
      out.width = w; out.height = h; const octx = out.getContext('2d');
      // draw video scaled to out
      octx.drawImage(video, 0, 0, w, h);
      // draw overlay elements scaled
      // scale factor between canvas (display) and video pixels
      const rect = canvas.getBoundingClientRect();
      const sx = w / rect.width; const sy = h / rect.height;
      // draw handles and line
      octx.strokeStyle = 'rgba(29,209,161,0.95)'; octx.fillStyle='rgba(29,209,161,0.95)'; octx.lineWidth = 4;
      if(handles.length>0){
        if(handles.length===2){ octx.beginPath(); octx.moveTo(handles[0].x*sx, handles[0].y*sy); octx.lineTo(handles[1].x*sx, handles[1].y*sy); octx.stroke(); }
        handles.forEach((p)=>{ octx.beginPath(); octx.arc(p.x*sx, p.y*sy, 16,0,Math.PI*2); octx.fill(); });
      }
      // add text
      octx.fillStyle='white'; octx.font = Math.max(20, Math.floor(w/40))+'px sans-serif'; octx.fillText(resultText.textContent || '', 16, 32);
      out.toBlob((blob)=>{ const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download = 'kaldif_screenshot.png'; a.click(); URL.revokeObjectURL(url); });
    }

    function convertUnits(v, from, to){
      // normalize to meters then to target
      const toM = {cm: v => v/100, m: v => v, in: v => v*0.0254}[from](v);
      const fromM = {cm: v => v*100, m: v => v, in: v => v/0.0254}[to];
      return fromM ? fromM(toM) : toM;
    }

    function euclid(a,b){ const dx=b.x-a.x; const dy=b.y-a.y; return Math.sqrt(dx*dx+dy*dy); }

    function updateResult(){
      if(handles.length<2){ return; }
      const dpx = euclid(handles[0], handles[1]);
      if(pxPerUnit){
        const val = dpx / pxPerUnit; // in selected unit
        let display = val;
        if(unit==='m'){ display = val.toFixed(3); }
        else if(unit==='cm'){ display = (val).toFixed(2); }
        else if(unit==='in'){ display = (val).toFixed(2); }
        resultText.textContent = display + ' ' + unit + ' ('+dpx.toFixed(1)+' px)';
      }else{
        resultText.textContent = dpx.toFixed(1)+' px (kalibrasi diperlukan)';
      }
    }

    // main draw loop
    function loop(){
      resizeIfNeeded();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const w = canvas.clientWidth, h = canvas.clientHeight;

      // draw vertical ruler centerline (improved ticks)
      const cx = w/2;
      ctx.save();
      ctx.strokeStyle = 'rgba(29,209,161,0.85)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(cx, 6); ctx.lineTo(cx, h-6); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.font='12px sans-serif'; ctx.textAlign='left';
      if(pxPerUnit){
        const pxPer = pxPerUnit; // px per unit
        const major = pxPer; // 1 unit per major tick
        const minor = Math.max(major/10, 6);
        // draw minor ticks
        for(let y=6; y<h-6; y+=minor){ ctx.beginPath(); ctx.moveTo(cx-6, y); ctx.lineTo(cx+6, y); ctx.stroke(); }
        // draw major ticks with labels
        const maxUnits = Math.ceil((h-12)/major)+1;
        for(let u=0; u<maxUnits; u++){
          const y = 6 + u*major;
          if(y>h-6) break;
          ctx.beginPath(); ctx.moveTo(cx-16, y); ctx.lineTo(cx+16, y); ctx.stroke();
          // label every unit or every 5 units if too dense
          const label = (u%5===0) ? (u + ' ' + unit) : (u);
          ctx.fillText(label, cx+18, y+4);
        }
      }else{
        for(let y=6;y<h-6;y+=50){ ctx.beginPath(); ctx.moveTo(cx-8,y); ctx.lineTo(cx+8,y); ctx.stroke(); ctx.fillText((y.toFixed(0))+' px', cx+12, y+4); }
      }
      ctx.restore();

      // draw handles and connecting line
      if(handles.length>0){
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.fillStyle='rgba(29,209,161,0.95)';
        handles.forEach((p,i)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,8,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.font='12px sans-serif'; ctx.fillText((i+1), p.x-4, p.y+4); ctx.fillStyle='rgba(29,209,161,0.95)'; });
        if(handles.length===2){ ctx.beginPath(); ctx.moveTo(handles[0].x, handles[0].y); ctx.lineTo(handles[1].x, handles[1].y); ctx.stroke(); }
      }

      requestAnimationFrame(loop);
    }

    let lastSize = {w:0,h:0};
    function resizeIfNeeded(){ const w=video.clientWidth,h=video.clientHeight; if(w!==lastSize.w||h!==lastSize.h){ lastSize={w,h}; resize(); } }

    startCamera();
  </script>
</body>
</html>